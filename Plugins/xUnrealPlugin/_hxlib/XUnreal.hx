package;

import unreal.macro.UXClassAnalyzer;
import unreal.macro.UXTypeConvert;
#if macro

import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type.ClassType;
import haxe.macro.TypeTools;
import sys.FileSystem;
import sys.io.File;
import unreal.macro.UXGenerateDelegates;

class XUnreal
{
	static public function buildTemplates(?baseClass:String)
	{
		var sourceFolder = "xUnrealPlugin";

		var mainClass="XUnrealMain";

		// Context 
		var className = Context.getLocalClass(); 
		var cls:Dynamic = className.get();
		var fields = Context.getBuildFields();
		// trace("CLASS: "+className);
		// trace("Fields: "+fields);

		// trace("xUnreal: "+className);

		// trace(cls.meta.get());//traces the metadata of the class
		// for (field in cls.fields.get())
		// {
		// 	trace(field.meta.get());//traces the metadata of each field
		// }

		// for (f in Reflect.fields(cls))
		// {
		// 	var fi = Reflect.field(cls,f);
		// 	trace(f+" : "+fi.meta);
		// }

		var preFix:String ="";
		var generate:Bool = true;

		var d:Array<Dynamic> = cls.meta.get();
		for (f in d)
		{
			var cMeta:String = f.name;
			if (cMeta==":nogenerate")
				generate = false;
			// if (cMeta==":uprefix")
			// {
			// 	var pList:Array<Dynamic> = f.params;
			// 	for (pm in pList)
			// 	{
			// 		if (pm!=null)
			// 		{
			// 			preFix = switch(pm.expr)
			// 			{
			// 				case EConst(CString(str)):str;
			// 				default:"";
			// 			}
			// 		}
			// 	}
			// }
		}
		
		var headH:String = "";
		var headCPP:String = "";

		if (generate)
		{
			headH+="/* 
* =============================================
* Generated by xUnreal - don't edit!
* =============================================
*/\n";
			headCPP=headH;
			
			var superClass:String = "Actor";
			if (cls.superClass!=null && cls.superClass.t!=null)
			{
				var superClassPath:String = cls.superClass.t.toString();
				superClass = superClassPath.substr(superClassPath.lastIndexOf(".")+1);
			}

			var baseClassStr:String = Std.string(baseClass);
			preFix = baseClassStr.charAt(0);
			var modulePath:String = cls.module;
			if (modulePath!=null)
				modulePath = modulePath.split(".").join("");
			else 
				modulePath="";

			var classNameStr:String = Std.string(className);
			var fnOnly:String = classNameStr;
			if (classNameStr.indexOf(".")!=-1)
				fnOnly = classNameStr.substr(classNameStr.lastIndexOf(".")+1);
			
			classNameStr = classNameStr.split(".").join("_");
			var FUclassNameStr = classNameStr.charAt(0).toUpperCase()+classNameStr.substr(1);
			fnOnly = fnOnly.charAt(0).toUpperCase()+fnOnly.substr(1);

			var packagePathOnly = "";
			if (classNameStr!=null && classNameStr.indexOf("_")!=-1)
			{
				var al = classNameStr.split("_");
				if (al.length>1)
				{
					al.pop();
					var nPaths:String = "_"+al.join("_");
					packagePathOnly = nPaths;
				}
			}

			var templateH:String = File.getContent('_hxlib/unreal/templates/$superClass.h.tmp');
			var templateCPP:String = File.getContent('_hxlib/unreal/templates/$superClass.cpp.tmp');
			var constructCPP:String = "";
			var destructCPP:String = "";
			var delegatesTop:String="";
			var delegatesFields:String="";
			var delegateBinds:String="";
			var delegateUnbinds:String="";
			var delegateActions:String="";
			var delegateDefinitions:String="";
			var classDef:String="UCLASS(BlueprintType, Blueprintable)";

			var exposedMethodsHeader:String = "";
			var exposedMethodsCpp:String = "";
			var delegateNumber:Int = 0;

			var df:Array<Dynamic> = fields.copy();
			for (bf in df)
			{
				var fieldName:String = bf.name;
				var fieldsMeta:Array<Dynamic> = bf.meta;

				var ueConstructorArgs:String = "";
				var ueConstructorInputParams:String = "";
				if (fieldName=="new")
				{
					var inputTypes = UXTypeConvert.extractInputTypesStr(bf);
					if (inputTypes.length>0)
					{
						ueConstructorArgs = UXTypeConvert.extractUEArgumentsStr(inputTypes);
						ueConstructorInputParams = UXTypeConvert.extractUEArgumentsInputStr(inputTypes);
					}
					templateCPP = StringTools.replace( templateCPP,"{$constructorArgs}",ueConstructorArgs);
					templateH = StringTools.replace(templateH,"{$constructorArgs}",ueConstructorArgs);
					templateCPP = StringTools.replace( templateCPP,"{$constructorInputParams}",ueConstructorInputParams);
					templateH = StringTools.replace(templateH,"{$constructorInputParams}",ueConstructorInputParams);
				}

				var gd = UXGenerateDelegates.generateDelegates(bf,modulePath,delegateNumber,superClass);
				delegateNumber = gd.delegateNumber;
				delegatesTop += gd.deledelegatesTop;
				delegatesFields += gd.delegatesFields;
				delegateBinds += gd.delegateBinds;
				delegateUnbinds += gd.delegateUnbinds;
				delegateDefinitions += gd.delegateDefinitions;
				delegateActions += gd.delegateActions;
				
				for (fm in fieldsMeta)
				{
					var metaName:String = Std.string(fm.name);
					if (metaName==":uexpose" || metaName==":ufunction")// || fm.name==":uproperty")
					{
						var staticaccessor:String = "";
						var isStatic = false;
						if (superClass=="BlueprintFunctionLibrary")
						{
							isStatic = UXClassAnalyzer.checkIfStatic(bf);
							if (isStatic)
								staticaccessor = "static ";
						}

						var metaParams:Array<Dynamic> = null;
						if (fm.params.length>0)
							metaParams = UXClassAnalyzer.extractMetaParams(fm.params);

						UXTypeConvert.swapFunctionTypes(bf);						
						var hxAtype:Array<RetArg> = UXTypeConvert.extractInputTypesStr(bf);						
						var ueAgruments:String = UXTypeConvert.extractUEArgumentsStr(hxAtype);
						var hxRtype:String = UXTypeConvert.extractReturnTypeStr(bf);
						var ueRType:String = UXTypeConvert.hxToUEReturnType(hxRtype);
						var ueInpArgsStr:String = UXTypeConvert.extractUEArgumentsInputStr(hxAtype);
						var retV:String = "return ";
						if (ueRType=="void")
							retV="";

						var category:String = "";
						var uFunction = UXClassAnalyzer.constructUFunctionMeta(isStatic,category,superClass,metaParams);

						exposedMethodsHeader+='\t$uFunction\n';
						exposedMethodsHeader+='\t$staticaccessor$ueRType ${bf.name}($ueAgruments);\n';

						exposedMethodsCpp+='$ueRType $preFix$fnOnly::${bf.name}($ueAgruments)\n';
						exposedMethodsCpp+='{\n';
						exposedMethodsCpp+='\t${retV}'+UXTypeConvert.injectTypeConvert(hxRtype,ueRType)+'(${mainClass}${packagePathOnly}_${fnOnly}_${bf.name}('+ (isStatic?"":"hxInst"+(hxAtype.length>0?", ":"")) + ueInpArgsStr +'));\n';
						exposedMethodsCpp = exposedMethodsCpp.split("Â¤").join("");
						exposedMethodsCpp+='}\n';
					}
					else if (metaName==":uproperty")
					{
						var hxRtype:String = UXTypeConvert.extractReturnTypeStrProp(bf);
						var ueRType:String = UXTypeConvert.hxToUEReturnType(hxRtype);

						var metaParams:Array<Dynamic> = null;
						if (fm.params.length>0)
							metaParams = UXClassAnalyzer.extractMetaParams(fm.params);

						var staticaccessor:String = "";
						var isStatic = false;
						if (superClass=="BlueprintFunctionLibrary")
						{
							isStatic = UXClassAnalyzer.checkIfStatic(bf);
							if (isStatic)
								staticaccessor = "static ";
						}

						var hxVtype:String = UXTypeConvert.extractValueTypeStr(bf);
						var ueVType:String = UXTypeConvert.hxToUEReturnType(hxVtype);

						var vv = switch(bf.kind)
						{
							case FVar(f):f;
							default:null;
						}						

						var vpms:Array<TypePath> = cast vv.getParameters();
						if (vpms!=null)
						{
							for (p in vpms)
							{
								for (pm in p.params)
								{

									var pmt:Array<Dynamic> = cast pm.getParameters();
									for (tmpt in pmt)
									{
										var tp:TypePath = tmpt;
										// trace(tp.name);
										// for (fn in f)
										// {
											// trace(f);
										// }
									}
								// var
								// for (tp in p.params)
								// {
									// trace(tp);
								// }
						// 		if (p!=null)
						// 			return p.name;
								}
							}
						}

						var category:String = "";
						var uProperty = UXClassAnalyzer.constructUPropertyMeta(isStatic,category,superClass,metaParams);						

						var bpGetter:String = "";
						var bpSetter:String = "";
						if (uProperty.indexOf("{__bpGet__}")!=-1)
						{
							bpGetter = '\tUFUNCTION(BlueprintPure, BlueprintInternalUseOnly) \n\t$ueVType GET${bf.name}() { return '+UXTypeConvert.injectTypeConvert(hxRtype,ueRType)+'(${mainClass}_${classNameStr}_GET${bf.name}(hxInst)); }\n';
							uProperty = StringTools.replace(uProperty,'{__bpGet__}','GET${bf.name}');


							// var fieldName:String = ${bf.name};
							// var setterName = 'set_TEST$fieldName';
							// var tmp_class = macro class
							// {
							// 	public var $fieldName(default, set):$fieldType = $fieldExpr;
							// 	public function $setterName(v:$fieldType):$fieldType {
							// 		if ($i{fieldName} != v) { // (field name as identifier)
							// 			$i{fieldName} = v;
							// 			$target.dispatchEvent(new ObservableEvent($v{fieldName}, v));
							// 		}
							// 		return v;
							// 	}
							// };
							// for (mcf in tmp_class.fields)
							// 	fields.push(mcf);			

							// fields.remove(bf); // remove the original field
							fields.push({
								name: 'GET' + fieldName,
								access : [APublic],
								kind: FieldType.FFun({ 
									args: [], 
									expr: macro return $i{fieldName}, 
									ret: null 
								}),
								pos: Context.currentPos()
							});
						}
						if (uProperty.indexOf("{__bpSet__}")!=-1)
						{
							bpSetter = '\tUFUNCTION(BlueprintCallable, BlueprintInternalUseOnly) \n\tvoid SET${bf.name}(const $ueVType val) { ${bf.name}=val; ${mainClass}_${classNameStr}_SET${bf.name}(hxInst,val); }\n';
							uProperty = StringTools.replace(uProperty,'{__bpSet__}','SET${bf.name}');

							fields.push({
								name: 'SET' + fieldName,
								// doc : "test",
								// meta : [],
								access : [APublic],
								kind: FieldType.FFun({ 
									args: [{ name:'value', type:null } ], 
									expr: macro { $i{fieldName} = value; return $i{fieldName} }, 
									ret: null 
								}),
								pos: Context.currentPos()
							});

						}

						exposedMethodsHeader+=bpGetter;
						exposedMethodsHeader+=bpSetter;
						exposedMethodsHeader+='\t$uProperty\n';
						exposedMethodsHeader+='\t$ueVType ${bf.name};\n';
						exposedMethodsHeader+='\n';
					}
					else if (metaName==":native")
					{
						var funcCode:String = "";

						var fieldsMeta:Array<Dynamic> = bf.meta;
						for (ifm in fieldsMeta)
						{
							var imetaName:String = Std.string(ifm.name);
							if (imetaName==":code")
							{
								var imetaParams:Array<Dynamic> = null;
								var iparams:Array<Dynamic> = ifm.params;
								if (iparams.length>0)
								{
									for (p in iparams)
									{
										switch(p.expr)
										{
											case EConst(CString(val)):
											{
												funcCode = val;
											}
											default:
										}
									}
								}
							}
						}
						if (funcCode!="")
						{
							var nc:String = "";
							var fa = funcCode.split('\n');
							for (l in fa)
								nc+="\t"+l+"\n";
							funcCode = nc;
						}

						exposedMethodsHeader+='\tvoid ${fieldName}();\n\n';
						exposedMethodsCpp+='void $preFix$fnOnly::${bf.name}()\n{\n${funcCode}\n}\n\n';
					}					
				}
			}

			exposedMethodsCpp+=delegateActions;
			exposedMethodsHeader+=delegatesFields+"\n";
			exposedMethodsHeader+=delegateDefinitions;
			headH+=delegatesTop;
			constructCPP+=delegateBinds;
			destructCPP+=delegateUnbinds;

			templateCPP = StringTools.replace(templateCPP,"{$construct}",constructCPP);
			templateCPP = StringTools.replace(templateCPP,"{$destruct} ",destructCPP);

			templateH = StringTools.replace(templateH,"{$exposedMethods}",exposedMethodsHeader);
			templateCPP = StringTools.replace(templateCPP,"{$exposedMethods}",exposedMethodsCpp);

			templateH = StringTools.replace(templateH,"{$head}",headH);
			templateCPP = StringTools.replace(templateCPP,"{$head}",headCPP);

			templateH = StringTools.replace(templateH,"{$hxMainClass}",mainClass);
			templateH = StringTools.replace(templateH,"{className}",fnOnly);
			templateH = StringTools.replace(templateH,"{$superClass}",superClass);
			templateH = StringTools.replace(templateH,"{$prefix}",preFix);
			templateH = StringTools.replace(templateH,"{$packagePath}",packagePathOnly);
			templateH = StringTools.replace(templateH,"{$classDef}",classDef);
			templateCPP = StringTools.replace(templateCPP,"{$hxMainClass}",mainClass);
			templateCPP = StringTools.replace(templateCPP,"{className}",fnOnly);
			templateCPP = StringTools.replace(templateCPP,"{$prefix}",preFix);
			templateCPP = StringTools.replace(templateCPP,"{$packagePath}",packagePathOnly);

			var folderName = "_xUnreal";	


			if (!sys.FileSystem.exists('Source/${sourceFolder}/_xUnreal'))
				sys.FileSystem.createDirectory('Source/${sourceFolder}/_xUnreal');
				
			sys.io.File.saveContent('Source/${sourceFolder}/_xUnreal/$fnOnly.h',templateH);
			sys.io.File.saveContent('Source/${sourceFolder}/_xUnreal/$fnOnly.cpp',templateCPP);

		}

		return fields;
	}

//	static function generateDelegates(bf:Dynamic,delegateNumber:Int)
// 	{
// 		var fieldName:String = bf.name;
// 		var baseDelegateStr:String = "DECLARE_DYNAMIC_MULTICAST_DELEGATE";
// 		var accessTypes:String = "BlueprintAssignable,BlueprintCallable";
// 		var delegatesTop:String="";
// 		var delegatesFields:String="";
// 		var delegateBinds:String="";
// 		var delegateUnbinds:String="";
// 		var delegateActions:String="";
// 		var delegateDefinitions:String="";

// 		var n = getFieldTypeName(bf);
// 		if (n=="DynamicMulticastDelegate")
// 		{
// 			var hxAtype:Array<RetArg> = extractInputTypesStr(bf);							
// 			var funcTypes = getFieldGenericFunctionTypes(bf);
// 			if (funcTypes.length>0)
// 			{
// 				var fLen:Int = funcTypes.length;
// 				if (fLen==1)
// 				{	
// 					delegateNumber++;
// 					var fn:String = 'FXUDelegate$delegateNumber';			
// 					var uet1:String = hxToUEReturnType(funcTypes[0]);			
// 					delegatesTop+='${baseDelegateStr}_OneParam($fn, $uet1, ${funcTypes[0]});\n';

// 					delegatesFields+='\tUPROPERTY($accessTypes)\n';
// 					delegatesFields+='\t$fn $fieldName;\n';
// 					delegateActions+='void '+"{$prefix}{className}"+'::On${fieldName}Event($uet1 ${funcTypes[0]})\n';				
// 					delegateActions+='{\n';	
// 					delegateActions+='\tif (GEngine!=NULL && haxeRunning && hxInst)\n';				
// 					delegateActions+='\t\tXUnrealMain_unreal_Object_incomingDelegate(hxInst,"${fieldName}",$fLen,${dynamicWrapper(funcTypes[0],uet1)},NULL,NULL);\n';				
// 					// delegateActions+='\t\tXUnrealMain_unreal_Object_incomingDelegate(hxInst,"${fieldName}",$fLen,${typeConvertHxtoHxStr(funcTypes[0],funcTypes[0])},NULL,NULL,NULL,NULL);\n';				
// 					delegateActions+='}\n';
// 					delegateDefinitions+='\tUFUNCTION()\n\tvoid On${fieldName}Event($uet1 ${funcTypes[0]});\n';		
// 				}					
// 				else if (funcTypes.length==2)
// 				{	
// 					delegateNumber++;
// 					var fn:String = 'FXUDelegate$delegateNumber';			
// 					var uet1:String = hxToUEReturnType(funcTypes[0]);			
// 					var uet2:String = hxToUEReturnType(funcTypes[1]);			
// 					delegatesTop+='${baseDelegateStr}_TwoParams($fn, $uet1, ${funcTypes[0]}, $uet2, ${funcTypes[1]});\n';

// 					delegatesFields+='\tUPROPERTY($accessTypes)\n';
// 					delegatesFields+='\t$fn $fieldName;\n';
// 					delegateActions+='void '+"{$prefix}{className}"+'::On${fieldName}Event($uet1 ${funcTypes[0]},$uet2 ${funcTypes[1]})\n';				
// 					delegateActions+='{\n';				
// 					delegateActions+='\tif (GEngine!=NULL && haxeRunning && hxInst)\n';				
// 					delegateActions+='\t\tXUnrealMain_unreal_Object_incomingDelegate(hxInst,"${fieldName}",$fLen,${dynamicWrapper(funcTypes[0],uet1)},${dynamicWrapper(funcTypes[1],uet2)},NULL);\n';				
// 					delegateActions+='}\n';	
// 					delegateDefinitions+='\tUFUNCTION()\n\tvoid On${fieldName}Event($uet1 ${funcTypes[0]},$uet2 ${funcTypes[1]});\n';		
// 				}					
// 				else if (funcTypes.length==3)
// 				{	
// 					delegateNumber++;
// 					var fn:String = 'FXUDelegate$delegateNumber';			
// 					var uet1:String = hxToUEReturnType(funcTypes[0]);			
// 					var uet2:String = hxToUEReturnType(funcTypes[1]);			
// 					var uet3:String = hxToUEReturnType(funcTypes[2]);			
// 					delegatesTop+='${baseDelegateStr}_ThreeParams($fn, $uet1, ${funcTypes[0]}, $uet2, ${funcTypes[1]}, $uet3, ${funcTypes[2]});\n';

// 					delegatesFields+='\tUPROPERTY($accessTypes)\n';
// 					delegatesFields+='\t$fn $fieldName;\n';
// 					delegateActions+='void '+"{$prefix}{className}"+'::On${fieldName}Event($uet1 ${funcTypes[0]},$uet2 ${funcTypes[1]},$uet3 ${funcTypes[2]})\n';				
// 					delegateActions+='{\n';				
// 					delegateActions+='\tif (GEngine!=NULL && haxeRunning && hxInst)\n';				
// 					delegateActions+='\t\tXUnrealMain_unreal_Object_incomingDelegate(hxInst,"${fieldName}",$fLen,${dynamicWrapper(funcTypes[0],uet1)},${dynamicWrapper(funcTypes[1],uet2)},${dynamicWrapper(funcTypes[2],uet3)});\n';				
// 					delegateActions+='}\n';				
// 					delegateDefinitions+='\tUFUNCTION()\n\tvoid On${fieldName}Event($uet1 ${funcTypes[0]},$uet2 ${funcTypes[1]},$uet3 ${funcTypes[2]});\n';		
// 				}					
// /* 				else if (funcTypes.length==4)
// 				{	
// 					delegateNumber++;
// 					var fn:String = 'FXUDelegate$delegateNumber';			
// 					var uet1:String = hxToUEReturnType(funcTypes[0]);			
// 					var uet2:String = hxToUEReturnType(funcTypes[1]);			
// 					var uet3:String = hxToUEReturnType(funcTypes[2]);			
// 					var uet4:String = hxToUEReturnType(funcTypes[3]);			
// 					delegatesTop+='${baseDelegateStr}_ThreeParams($fn, $uet1, ${funcTypes[0]}, $uet2, ${funcTypes[1]}, $uet3, ${funcTypes[2]}, $uet4, ${funcTypes[3]});\n';

// 					delegatesFields+='\tUPROPERTY($accessTypes)\n';
// 					delegatesFields+='\t$fn $fieldName;\n';
// 					delegateActions+='void '+"{$prefix}{className}"+'::On${fieldName}Event($uet1 ${funcTypes[0]}, $uet2 ${funcTypes[1]}, $uet3 ${funcTypes[2]}, $uet4 ${funcTypes[3]})\n';				
// 					delegateActions+='{\n';				
// 					// delegateActions+='\tif (GEngine!=NULL && haxeRunning && hxInst)\n';				
// 					// delegateActions+='\t\tXUnrealMain_unreal_Object_incomingDelegate(hxInst,"${fieldName}",$fLen,${typeConvertHxtoHxStr(funcTypes[0],funcTypes[0])},${typeConvertHxtoHxStr(funcTypes[1],funcTypes[1])},${typeConvertHxtoHxStr(funcTypes[2],funcTypes[2])},${typeConvertHxtoHxStr(funcTypes[3],funcTypes[3])},NULL);\n';				
// 					delegateActions+='}\n';				
// 					delegateDefinitions+='\tUFUNCTION()\n\tvoid On${fieldName}Event($uet1 ${funcTypes[0]}, $uet2 ${funcTypes[1]}, $uet3 ${funcTypes[2]}, $uet4 ${funcTypes[3]});\n';	
// 				}					
// 				else if (funcTypes.length==5)
// 				{	
// 					delegateNumber++;
// 					var fn:String = 'FXUDelegate$delegateNumber';			
// 					var uet1:String = hxToUEReturnType(funcTypes[0]);			
// 					var uet2:String = hxToUEReturnType(funcTypes[1]);			
// 					var uet3:String = hxToUEReturnType(funcTypes[2]);			
// 					var uet4:String = hxToUEReturnType(funcTypes[3]);			
// 					var uet5:String = hxToUEReturnType(funcTypes[4]);			
// 					delegatesTop+='${baseDelegateStr}_ThreeParams($fn, $uet1, ${funcTypes[0]}, $uet2, ${funcTypes[1]}, $uet3, ${funcTypes[2]}, $uet4, ${funcTypes[3]}), $uet5, ${funcTypes[4]});\n';

// 					delegatesFields+='\tUPROPERTY($accessTypes)\n';
// 					delegatesFields+='\t$fn $fieldName;\n';
// 					delegateActions+='void '+"{$prefix}{className}"+'::On${fieldName}Event($uet1 ${funcTypes[0]}, $uet2 ${funcTypes[1]}, $uet3 ${funcTypes[2]}, $uet4 ${funcTypes[3]}, $uet5 ${funcTypes[4]})\n';				
// 					delegateActions+='{\n';				
// 					// delegateActions+='\tif (GEngine!=NULL && haxeRunning && hxInst)\n';				
// 					// delegateActions+='\t\tXUnrealMain_unreal_Object_incomingDelegate(hxInst,"${fieldName}",$fLen,${typeConvertHxtoHxStr(funcTypes[0],funcTypes[0])},${typeConvertHxtoHxStr(funcTypes[1],funcTypes[1])},${typeConvertHxtoHxStr(funcTypes[2],funcTypes[2])},${typeConvertHxtoHxStr(funcTypes[3],funcTypes[3])},${typeConvertHxtoHxStr(funcTypes[3],funcTypes[3])});\n';				
// 					delegateActions+='}\n';				
// 					delegateDefinitions+='\tvoid On${fieldName}Event($uet1 ${funcTypes[0]}, $uet2 ${funcTypes[1]}, $uet3 ${funcTypes[2]}, $uet4 ${funcTypes[3]}, $uet5 ${funcTypes[4]});\n';	
// 				}					
//  */
// 				delegateBinds+='\t$fieldName.AddDynamic(this, &'+"{$prefix}{className}"+'::On${fieldName}Event);\n';				
// 				delegateUnbinds+='\t$fieldName.RemoveDynamic(this, &'+"{$prefix}{className}"+'::On${fieldName}Event);\n';				
// 			}
// 		}
		
// 		return 
// 		{
// 			delegateNumber:delegateNumber,
// 			deledelegatesTop:delegatesTop,
// 			delegatesFields:delegatesFields,
// 			delegateBinds:delegateBinds,
// 			delegateUnbinds:delegateUnbinds,
// 			delegateActions:delegateActions,
// 			delegateDefinitions:delegateDefinitions
// 		};
// 	}				


/*

void UAddGlobalEvent::Activate()
{
	UXUnrealGameInstance* gInst = UXUnrealBPFL::XUnrealGameInstance();
	if (gInst)
	{
		gInst->GlobalEvent.AddDynamic(this, &UAddGlobalEvent::OnGlobalEvent);
	}
}

void UAddGlobalEvent::OnGlobalEvent(FString EventName, FString Payload)
{
	if (EventNameStr == EventName)
	{
		OnEvent.Broadcast(Payload);
	}
}

void UAddGlobalEvent::SetReadyToDestroy()
{
	UXUnrealGameInstance* gInst = UXUnrealBPFL::XUnrealGameInstance();
	if (gInst)
	{
		gInst->GlobalEvent.RemoveDynamic(this, &UAddGlobalEvent::OnGlobalEvent);
	}

	Super::SetReadyToDestroy();
}


*/

/* 

	static function extractUEArgumentsStr(rArgs:Array<RetArg>):String
	{
		var ret = "";
		if (rArgs!=null && rArgs.length>0)
		{
			for (a in rArgs)
			{
				ret+=hxToUEReturnType(a.argType)+" "+a.argName+", ";
			}
			ret = ret.substring(0, ret.length-2);			
		}
		return ret;
	}

	static function extractUEArgumentsInputStr(rArgs:Array<RetArg>):String
	{
		var ret = "";
		if (rArgs!=null && rArgs.length>0)
		{
			for (a in rArgs)
			{
				ret+=typeConvertHxtoHxStr(a.argType,a.argName)+", ";
			}
			ret = ret.substring(0, ret.length-2);			
		}
		return ret;
	}

	static function extractInputTypesStr(bf):Array<RetArg>
	{
		var func = switch(bf.kind)
		{
			case FFun(f):f;
			default:null;
		}						

		var rArgs:Array<RetArg> = [];
		if (func!=null && func.args!=null)
		{
			for (a in func.args)
			{
				if (a!=null)
				{
					var ra:RetArg = {argName:null,argType:null};
					if (a.name!=null)
						ra.argName = a.name;
					if (a.type!=null)
					{
						var tp = switch(a.type)
						{
							case TPath(t):t;
							default:null;
						}
						ra.argType = tp.name;			
					}
					rArgs.push(ra);
				}
			}
		}
		return rArgs;
	}
	
	static function extractReturnTypeStr(bf):String
	{
		var func = switch(bf.kind)
		{
			case FFun(f):f;
			default:null;
		}						

		if (func.ret==null)
			return "";

		var pms:Array<Dynamic> = func.ret.getParameters();
		if (pms!=null)
		{
			for (p in pms)
			{
				if (p!=null)
					return p.name;
			}
		}
		return null;
	}

	static function extractValueTypeStr(bf):String
	{
		var variable = switch(bf.kind)
		{
			case FVar(v):v;
			default:null;
		}			

		var pms:Array<Dynamic> = variable.getParameters();
		if (pms!=null)
		{
			for (p in pms)
			{
				if (p!=null)
					return p.name;
			}
		}
		return null;
	}

	static function hxToUEReturnType(hxrt:String):String
	{
		return switch(hxrt)
		{
			case "Dynamic"		: "FHaxeObject";
			case "String"		: "FString";
			case "Int"			: "int";
			case "Float"		: "float";
			case "Bool"			: "bool";
			case "Void"			: "void";
			case ""				: "void";
			default: hxrt;
		}
	}

	// static function typeConvertUEtoHxStr(ueType:String,val:String=""):String
	static function typeConvertHxtoHxStr(ueType:String,val:String=""):String
	{
		var rval = switch(ueType)
		{
			// case "String"		: '_FStringToHaxeString($val)';
			case "String"		: 'TCHAR_TO_UTF8(*$val)';
			case "Dynamic"		: '_UEToHaxeObject($val)';
			default: val;
		}
		return rval;
	}

	static function dynamicWrapper(?valName:String,typeName:String=""):String
	{
		if (valName==null)
			return '_UEAnyToHaxeDynamic("","",-1).ref()';

		var typeCode:Int = switch(typeName)
		{
			case "FString"		: 1;
			case "float"		: 2;
			case "int"			: 3;
			case "bool"			: 4;
			case "FHaxeObject"	: 5;
			case _				: 0;
		}
	
		return '_UEAnyToHaxeDynamic(&$valName,"$typeName",$typeCode).ref()';
		// var rval = switch(ueType)
		// {
		// 	// case "String"		: '_FStringToHaxeString($val)';
		// 	case "String"		: 'TCHAR_TO_UTF8(*$val)';
		// 	case "Dynamic"		: '_UEAnyToHaxeDynamic($val)';
		// 	default: val;
		// }
		// return rval;
	}

	static function injectTypeConvert(hxType:String,ueType:String):String
	{
		if (hxType=="String")
		{
			return switch(ueType)
			{
				case "FString"			: "_HaxeStringToFString";
				default: "";
			}
		}
		else if (hxType=="Dynamic")
		{
			return switch(ueType)
			{
				case "FHaxeObject"		: "_HaxeObjectToUE";
				default: "";
			}
		}
		return "";
	}
 */
/* 	static function checkIfStatic(bf):Bool
	{
		var isStatic:Bool = false;
		var accessList:Array<Dynamic> = bf.access;
		for (ac in accessList)
			if (Std.string(ac)=="AStatic")
				isStatic = true;
		return isStatic;
	}

	static function constructUFunctionMeta(?isStatic:Null<Bool>,?category:String,superClass:String,metaParams:Array<Dynamic>):String
	{
		var out:String ="";

		var addBPCallable:Bool = false;
		if (superClass=="BlueprintFunctionLibrary")
			addBPCallable = true;

		if (metaParams!=null)
		{
			for (mp in metaParams)
			{
				if (Std.isOfType(mp,String))
				{
					out+='$mp, ';
					if (Std.string(mp).toLowerCase()=="blueprintcallable")
						addBPCallable=false;
				}
				else if (Std.isOfType(mp,Dynamic))
				{
					if (Std.string(mp.identvars)!=null && Std.string(mp.values)!=null)
					{
						if (Std.string(mp.identvars).toLowerCase()=="category")
							category=Std.string(mp.values);
					}
				}
			}
		}

		if (addBPCallable)	
			out+='BlueprintCallable, ';
		if (category!=null && category!="")
			out+='Category = "xUnreal|$category"';
		else
			out+='Category = "xUnreal"';

		return 'UFUNCTION('+out+')';
	}

	static function extractMetaParams(params:Array<Dynamic>)
	{
		var metaValues:Array<Dynamic> = [];
		for (p in params)
		{
			switch(p.expr)
			{
				case EConst(CIdent(metaIdent)):
				{
					metaValues.push(metaIdent);
				}
				case EBinop(OpAssign, varsExpr, valuesExpr):
				{
					var ident:String = switch(varsExpr.expr)
					{
						case EConst(CIdent(metaIdent)):metaIdent;
						// case EConst(CString(metaStr)):
						// {
						// 	mLine+=metaStr;
						// }
						// case EConst(CString(ident)):
						// {
						// 	metaValues.push(ident);
						// };
						default:"";
					}
					var value:String = switch(valuesExpr.expr)
					{
						case EConst(CString(metaStr)): metaStr;
						default: "";
					}
					metaValues.push({identvars:ident,values:value});
				}
				default:
			}
		}
		return metaValues;
	}

	static function constructUPropertyMeta(?isStatic:Null<Bool>,?category:String,superClass:String,metaParams:Array<Dynamic>):String
	{
		var out:String ="";

		var addUpropGet:Bool = false;
		var addUpropSet:Bool = false;

		if (metaParams!=null)
		{
			for (mp in metaParams)
			{
				if (Std.isOfType(mp,String))
				{
					out+='$mp, ';
					switch(Std.string(mp).toLowerCase())
					{
						case "editanywhere" :
						{
							addUpropGet = true;	
							addUpropSet = true;	
						}
						case "visibleanywhere" :
						{
							addUpropGet = true;	
						}
						case "blueprintreadwrite" :
						{
							addUpropGet = true;	
							addUpropSet = true;	
						}
						case "blueprintreadonly" :
						{
							addUpropGet = true;	
							addUpropSet = false;	
						}
						// case "blueprintgetter" :
						// case "blueprintsetter" :
						// case "blueprintassignable" :
						// case "blueprintcallable" :
						default:
					}
				}
				else if (Std.isOfType(mp,Dynamic))
				{
					if (Std.string(mp.identvars)!=null && Std.string(mp.values)!=null)
					{
						if (Std.string(mp.identvars).toLowerCase()=="category")
							category=Std.string(mp.values);
					}
				}
			}
		}

		if (addUpropGet)	
			out+='BlueprintGetter={__bpGet__}, ';
		if (addUpropSet)	
			out+='BlueprintSetter={__bpSet__}, ';
		if (category!=null && category!="")
			out+='Category = "xUnreal|$category"';
		else
			out+='Category = "xUnreal"';

		return 'UPROPERTY('+out+')';
	}

	static function getFieldTypeName(f:Dynamic):String
	{
		if (f==null)
			return null;
			
		var fv = switch(f.kind)
		{
			case FVar(f):f;
			default:null;
		}
		if (fv==null)
			return null;

		var fp = switch(fv)
		{
			case TPath(f):f;
			default:null;
		}

		if (fp!=null)
			return fp.name;
		else
			return null;
	}

	static function getFieldGenericFunctionTypes(f:Dynamic):Array<String>
	{
		if (f==null)
			return null;
			
		var fv = switch(f.kind)
		{
			case FVar(f):f;
			default:null;
		}
		if (fv==null)
			return null;

		var fp = switch(fv)
		{
			case TPath(f):f;
			default:null;
		}

		var funcData:Array<String> = [];

		for (tp in fp.params)
		{
			var tpt = switch(tp)
			{
				case TPType(f):f;
				default:null;
			}
			if (tpt!=null)
			{
				var funcParams:Array<Dynamic> = tpt.getParameters();	
				if (funcParams!=null && funcParams.length>1)
				{
					var ftp:Array<Dynamic> = funcParams[0];
					if (ftp!=null)
					{
						for (tftp in ftp)
						{
							var tftptp = switch(tftp)
							{
								case TPath(f):f;
								default:null;
							}
							if (tftptp!=null)
								funcData.push(tftptp.name);
						}
					}
				}		
			}
		}

		return funcData;
	}
 */
}

typedef RetArg =
{
	var argName:String;
	var argType:String;
}

#end