import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type.ClassType;
import haxe.macro.TypeTools;
import sys.FileSystem;
import sys.io.File;

class XUnreal
{
	static public function buildTemplates(?baseClass:String)
	{
		var sourceFolder = "xUnreal5";

		var mainClass="XUnrealMain";

		// Context 
		var className =Context.getLocalClass(); 
		var cls:Dynamic = className.get();
		var fields = Context.getBuildFields();
		// trace("CLASS: "+className);
		// trace("Fields: "+fields);

		// trace("xUnreal: "+className);

		// trace(cls.meta.get());//traces the metadata of the class
		// for (field in cls.fields.get())
		// {
		// 	trace(field.meta.get());//traces the metadata of each field
		// }

		// for (f in Reflect.fields(cls))
		// {
		// 	var fi = Reflect.field(cls,f);
		// 	trace(f+" : "+fi.meta);
		// }

		var preFix:String ="";
		var generate:Bool = true;

		var d:Array<Dynamic> = cls.meta.get();
		for (f in d)
		{
			var cMeta:String = f.name;
			if (cMeta==":nogenerate")
				generate = false;
			// if (cMeta==":uprefix")
			// {
			// 	var pList:Array<Dynamic> = f.params;
			// 	for (pm in pList)
			// 	{
			// 		if (pm!=null)
			// 		{
			// 			preFix = switch(pm.expr)
			// 			{
			// 				case EConst(CString(str)):str;
			// 				default:"";
			// 			}
			// 		}
			// 	}
			// }
		}
		
		if (generate)
		{
			var disclaimer ="/* 
* =============================================
* Generated by xUnreal - don't edit!
* =============================================
*/";

			var superClass:String = "Actor";
			if (cls.superClass!=null && cls.superClass.t!=null)
			{
				var superClassPath:String = cls.superClass.t.toString();
				superClass = superClassPath.substr(superClassPath.lastIndexOf(".")+1);
			}

			var baseClassStr:String = Std.string(baseClass);
			preFix = baseClassStr.charAt(0);

			var classNameStr:String = Std.string(className);
			var fnOnly:String = classNameStr;
			if (classNameStr.indexOf(".")!=-1)
				fnOnly = classNameStr.substr(classNameStr.lastIndexOf(".")+1);
			
			classNameStr = classNameStr.split(".").join("_");
			var FUclassNameStr = classNameStr.charAt(0).toUpperCase()+classNameStr.substr(1);
			fnOnly = fnOnly.charAt(0).toUpperCase()+fnOnly.substr(1);

			var templateH:String = File.getContent('_hxlib/unreal/templates/$superClass.h.tmp');
			var templateCPP:String = File.getContent('_hxlib/unreal/templates/$superClass.cpp.tmp');

			templateH = StringTools.replace(templateH,"{$hxMainClass}",mainClass);
			templateH = StringTools.replace(templateH,"{className}",fnOnly);
			templateH = StringTools.replace(templateH,"{$superClass}",superClass);
			templateH = StringTools.replace(templateH,"{$prefix}",preFix);
			templateCPP = StringTools.replace(templateCPP,"{$hxMainClass}",mainClass);
			templateCPP = StringTools.replace(templateCPP,"{className}",fnOnly);
			templateCPP = StringTools.replace(templateCPP,"{$prefix}",preFix);

			var exposedMethodsHeader:String = "";
			var exposedMethodsCpp:String = "";

			var df:Array<Dynamic> = fields.copy();
			for (bf in df)
			{
				var fieldName:String = bf.name;
				var fieldsMeta:Array<Dynamic> = bf.meta;
				for (fm in fieldsMeta)
				{
					var metaName:String = Std.string(fm.name);
					if (metaName==":uexpose" || metaName==":ufunction")// || fm.name==":uproperty")
					{
						var staticaccessor:String = "";
						var isStatic = false;
						if (superClass=="BlueprintFunctionLibrary")
						{
							isStatic = checkIfStatic(bf);
							if (isStatic)
								staticaccessor = "static ";
						}

						var metaParams:Array<Dynamic> = null;
						if (fm.params.length>0)
							metaParams = extractMetaParams(fm.params);

						var hxAtype:Array<RetArg> = extractInputTypesStr(bf);						
						var ueAgruments:String = extractUEArgumentsStr(hxAtype);
						var hxRtype:String = extractReturnTypeStr(bf);
						var ueRType:String = hxToUEReturnType(hxRtype);
						var ueInpArgsStr:String = extractUEArgumentsInputStr(hxAtype);

						var category:String = "";
						var uFunction = constructUFunctionMeta(isStatic,category,superClass,metaParams);

						exposedMethodsHeader+='\t$uFunction\n';
						exposedMethodsHeader+='\t$staticaccessor$ueRType ${bf.name}($ueAgruments);\n';

						exposedMethodsCpp+='$ueRType $preFix$fnOnly::${bf.name}($ueAgruments)\n';
						exposedMethodsCpp+='{\n';
						exposedMethodsCpp+='\treturn '+injectTypeConvert(hxRtype,ueRType)+'(${mainClass}_${fnOnly}_${bf.name}('+ (isStatic?"":"hxInst"+(hxAtype.length>0?", ":"")) + ueInpArgsStr +'));\n';
						exposedMethodsCpp = exposedMethodsCpp.split("Â¤").join("");
						exposedMethodsCpp+='}\n';
					}
					else if (metaName==":uproperty")
					{
						var metaParams:Array<Dynamic> = null;
						if (fm.params.length>0)
							metaParams = extractMetaParams(fm.params);

						var staticaccessor:String = "";
						var isStatic = false;
						if (superClass=="BlueprintFunctionLibrary")
						{
							isStatic = checkIfStatic(bf);
							if (isStatic)
								staticaccessor = "static ";
						}

						var hxVtype:String = extractValueTypeStr(bf);
						var ueVType:String = hxToUEReturnType(hxVtype);

						var vv = switch(bf.kind)
						{
							case FVar(f):f;
							default:null;
						}						

						var vpms:Array<TypePath> = cast vv.getParameters();
						if (vpms!=null)
						{
							for (p in vpms)
							{
								for (pm in p.params)
								{

									var pmt:Array<Dynamic> = cast pm.getParameters();
									for (tmpt in pmt)
									{
										var tp:TypePath = tmpt;
										// trace(tp.name);
										// for (fn in f)
										// {
											// trace(f);
										// }
									}
								// var
								// for (tp in p.params)
								// {
									// trace(tp);
								// }
						// 		if (p!=null)
						// 			return p.name;
								}
							}
						}

						var category:String = "";
						var uProperty = constructUPropertyMeta(isStatic,category,superClass,metaParams);						

						var bpGetter:String = "";
						var bpSetter:String = "";
						if (uProperty.indexOf("{__bpGet__}")!=-1)
						{
							bpGetter = '\tUFUNCTION(BlueprintPure, BlueprintInternalUseOnly) \n\t$ueVType GET${bf.name}() { return ${mainClass}_${classNameStr}_GET${bf.name}(hxInst); }\n';
							uProperty = StringTools.replace(uProperty,'{__bpGet__}','GET${bf.name}');


							// var fieldName:String = ${bf.name};
							// var setterName = 'set_TEST$fieldName';
							// var tmp_class = macro class
							// {
							// 	public var $fieldName(default, set):$fieldType = $fieldExpr;
							// 	public function $setterName(v:$fieldType):$fieldType {
							// 		if ($i{fieldName} != v) { // (field name as identifier)
							// 			$i{fieldName} = v;
							// 			$target.dispatchEvent(new ObservableEvent($v{fieldName}, v));
							// 		}
							// 		return v;
							// 	}
							// };
							// for (mcf in tmp_class.fields)
							// 	fields.push(mcf);			

							// fields.remove(bf); // remove the original field
							fields.push({
								name: 'GET' + fieldName,
								access : [APublic],
								kind: FieldType.FFun({ 
									args: [], 
									expr: macro return $i{fieldName}, 
									ret: null 
								}),
								pos: Context.currentPos()
							});
						}
						if (uProperty.indexOf("{__bpSet__}")!=-1)
						{
							bpSetter = '\tUFUNCTION(BlueprintCallable, BlueprintInternalUseOnly) \n\tvoid SET${bf.name}(const $ueVType val) { ${bf.name}=val; ${mainClass}_${classNameStr}_SET${bf.name}(hxInst,val); }\n';
							uProperty = StringTools.replace(uProperty,'{__bpSet__}','SET${bf.name}');

							fields.push({
								name: 'SET' + fieldName,
								// doc : "test",
								// meta : [],
								access : [APublic],
								kind: FieldType.FFun({ 
									args: [{ name:'value', type:null } ], 
									expr: macro { $i{fieldName} = value; return $i{fieldName} }, 
									ret: null 
								}),
								pos: Context.currentPos()
							});

						}

						exposedMethodsHeader+=bpGetter;
						exposedMethodsHeader+=bpSetter;
						exposedMethodsHeader+='\t$uProperty\n';
						exposedMethodsHeader+='\t$ueVType ${bf.name};\n';
						exposedMethodsHeader+='\n';
					}
				}
			}

			templateH = StringTools.replace(templateH,"{$exposedMethods}",exposedMethodsHeader);
			templateCPP = StringTools.replace(templateCPP,"{$exposedMethods}",exposedMethodsCpp);

			templateH = StringTools.replace(templateH,"{$disclaimer}",disclaimer);
			templateCPP = StringTools.replace(templateCPP,"{$disclaimer}",disclaimer);

			var folderName = "_xUnreal";	


			if (!sys.FileSystem.exists('Source/${sourceFolder}/_xUnreal'))
				sys.FileSystem.createDirectory('Source/${sourceFolder}/_xUnreal');
				
			sys.io.File.saveContent('Source/${sourceFolder}/_xUnreal/$fnOnly.h',templateH);
			sys.io.File.saveContent('Source/${sourceFolder}/_xUnreal/$fnOnly.cpp',templateCPP);

		}

		return fields;
	}

	static function extractUEArgumentsStr(rArgs:Array<RetArg>):String
	{
		var ret = "";
		if (rArgs!=null && rArgs.length>0)
		{
			for (a in rArgs)
			{
				ret+=hxToUEReturnType(a.argType)+" "+a.argName+", ";
			}
			ret = ret.substring(0, ret.length-2);			
		}
		return ret;
	}

	static function extractUEArgumentsInputStr(rArgs:Array<RetArg>):String
	{
		var ret = "";
		if (rArgs!=null && rArgs.length>0)
		{
			for (a in rArgs)
			{
				ret+=typeConvertHxtoHxStr(a.argType,a.argName)+", ";
			}
			ret = ret.substring(0, ret.length-2);			
		}
		return ret;
	}

	static function extractInputTypesStr(bf):Array<RetArg>
	{
		var func = switch(bf.kind)
		{
			case FFun(f):f;
			default:null;
		}						

		var rArgs:Array<RetArg> = [];
		if (func!=null && func.args!=null)
		{
			for (a in func.args)
			{
				if (a!=null)
				{
					var ra:RetArg = {argName:null,argType:null};
					if (a.name!=null)
						ra.argName = a.name;
					if (a.type!=null)
					{
						var tp = switch(a.type)
						{
							case TPath(t):t;
							default:null;
						}
						ra.argType = tp.name;			
					}
					rArgs.push(ra);
				}
			}
		}
		return rArgs;
	}
	
	static function extractReturnTypeStr(bf):String
	{
		var func = switch(bf.kind)
		{
			case FFun(f):f;
			default:null;
		}						

		if (func.ret==null)
			return "";

		var pms:Array<Dynamic> = func.ret.getParameters();
		if (pms!=null)
		{
			for (p in pms)
			{
				if (p!=null)
					return p.name;
			}
		}
		return null;
	}

	static function extractValueTypeStr(bf):String
	{
		var variable = switch(bf.kind)
		{
			case FVar(v):v;
			default:null;
		}			

		var pms:Array<Dynamic> = variable.getParameters();
		if (pms!=null)
		{
			for (p in pms)
			{
				if (p!=null)
					return p.name;
			}
		}
		return null;
	}

	static function hxToUEReturnType(hxrt:String):String
	{
		return switch(hxrt)
		{
			case "String"		: "FString";
			case "Int"			: "int";
			case "Float"		: "float";
			case "Bool"			: "bool";
			case "Void"			: "void";
			case ""				: "void";
			default: hxrt;
		}
	}

	// static function typeConvertUEtoHxStr(ueType:String,val:String=""):String
	static function typeConvertHxtoHxStr(ueType:String,val:String=""):String
	{
		var rval = switch(ueType)
		{
			// case "String"		: '_FStringToHaxeString($val)';
			case "String"		: 'TCHAR_TO_UTF8(*$val)';
			default: val;
		}
		return rval;
	}

	static function injectTypeConvert(hxType:String,ueType:String):String
	{
		if (hxType=="String")
		{
			return switch(ueType)
			{
				case "FString"		: "_HaxeStringToFString";
				default: "";
			}
		}
		return "";
	}

	static function checkIfStatic(bf):Bool
	{
		var isStatic:Bool = false;
		var accessList:Array<Dynamic> = bf.access;
		for (ac in accessList)
			if (Std.string(ac)=="AStatic")
				isStatic = true;
		return isStatic;
	}

	static function constructUFunctionMeta(?isStatic:Null<Bool>,?category:String,superClass:String,metaParams:Array<Dynamic>):String
	{
		var out:String ="";

		var addBPCallable:Bool = false;
		if (superClass=="BlueprintFunctionLibrary")
			addBPCallable = true;

		if (metaParams!=null)
		{
			for (mp in metaParams)
			{
				if (Std.isOfType(mp,String))
				{
					out+='$mp, ';
					if (Std.string(mp).toLowerCase()=="blueprintcallable")
						addBPCallable=false;
				}
				else if (Std.isOfType(mp,Dynamic))
				{
					if (Std.string(mp.identvars)!=null && Std.string(mp.values)!=null)
					{
						if (Std.string(mp.identvars).toLowerCase()=="category")
							category=Std.string(mp.values);
					}
				}
			}
		}

		if (addBPCallable)	
			out+='BlueprintCallable, ';
		if (category!=null && category!="")
			out+='Category = "xUnreal|$category"';
		else
			out+='Category = "xUnreal"';

		return 'UFUNCTION('+out+')';
	}

	static function extractMetaParams(params:Array<Dynamic>)
	{
		var metaValues:Array<Dynamic> = [];
		for (p in params)
		{
			switch(p.expr)
			{
				case EConst(CIdent(metaIdent)):
				{
					metaValues.push(metaIdent);
				}
				case EBinop(OpAssign, varsExpr, valuesExpr):
				{
					var ident:String = switch(varsExpr.expr)
					{
						case EConst(CIdent(metaIdent)): metaIdent;
						// case EConst(CString(metaStr)):
						// {
						// 	mLine+=metaStr;
						// }
						default:"";
					}
					var value:String = switch(valuesExpr.expr)
					{
						case EConst(CString(metaStr)): metaStr;
						default: "";
					}
					metaValues.push({identvars:ident,values:value});
				}
				default:
			}
		}
		return metaValues;
	}

	static function constructUPropertyMeta(?isStatic:Null<Bool>,?category:String,superClass:String,metaParams:Array<Dynamic>):String
	{
		var out:String ="";

		var addUpropGet:Bool = false;
		var addUpropSet:Bool = false;

		if (metaParams!=null)
		{
			for (mp in metaParams)
			{
				if (Std.isOfType(mp,String))
				{
					out+='$mp, ';
					switch(Std.string(mp).toLowerCase())
					{
						case "editanywhere" :
						{
							addUpropGet = true;	
							addUpropSet = true;	
						}
						case "visibleanywhere" :
						{
							addUpropGet = true;	
						}
						case "blueprintreadwrite" :
						{
							addUpropGet = true;	
							addUpropSet = true;	
						}
						case "blueprintreadonly" :
						{
							addUpropGet = true;	
							addUpropSet = false;	
						}
						// case "blueprintgetter" :
						// case "blueprintsetter" :
						// case "blueprintassignable" :
						// case "blueprintcallable" :
						default:
					}
				}
				else if (Std.isOfType(mp,Dynamic))
				{
					if (Std.string(mp.identvars)!=null && Std.string(mp.values)!=null)
					{
						if (Std.string(mp.identvars).toLowerCase()=="category")
							category=Std.string(mp.values);
					}
				}
			}
		}

		if (addUpropGet)	
			out+='BlueprintGetter={__bpGet__}, ';
		if (addUpropSet)	
			out+='BlueprintSetter={__bpSet__}, ';
		if (category!=null && category!="")
			out+='Category = "xUnreal|$category"';
		else
			out+='Category = "xUnreal"';

		return 'UPROPERTY('+out+')';
	}

}

typedef RetArg =
{
	var argName:String;
	var argType:String;
}